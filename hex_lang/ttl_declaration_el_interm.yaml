ttl: # lake-root-level key (true typeless) intended to declare objects and relations

#___________________________________________________________________________________________
#_____________________________________ elementary __________________________________________

  obj1: # id or ttl key 'obj1' assigned to object
    attribute1_key: attribute1_value # some object's (obj1) attribute key:value pair
    attribute2_key: attribute2_value # another object's attribute key:value pair

  obj2: # id or ttl key 'obj2' assigned to object
    attribute1_key: attribute1_value # some object's (obj2) attribute key: value pair

                    # Attributes values could be any yaml valid mapping, sequence or scalar. 
                    # Any of this have no semantic meaning for Hexagon, except
                    # hex-attribute (see hex section). But attributes can play role when
                    # data is being validated by domain specific rules or be valuable for
                    # presentation rendering purposes

  # It doesn't matter the order or manifest where object is declared - all ttl objects
  # are in lake at the same time

  obj3: 
    hex: # hex-attribute key of obj3 intended to in-ttl declare relation(s) of obj3
         # Hexagon treats all relations directional, i.e. having one 'source object' (obj3)
         # and one 'target object'
      obj1: # one of declared ttl objects now gets additional declaration as target
            # in relation with obj3 (source)
      obj2: # another one of declared ttl objects declared additionally as target
            # in relation with obj3 (source)


#___________________________________________________________________________________________
#_____________________________________ intermediate ________________________________________

  # You may want to make difference between relations, i.e. assign kinda type to them

  obj4:
    hex:
      obj3: type1  # obj4 has outbound type1 relation to obj3
                   # or opposite reading - obj3 has inbound type1 relation from obj4
      obj2: type2  # the same but type 2 to obj2
      obj1: type1  # type 1 again but to obj1

  # Normally you declare relations FROM declaring object key through hex attribute TO other
  # objects keys. But sometimes you're more comfortable with 'reverse' relation declaration

  obj5:
    hex:
      obj6: (<).type1       # obj5 has inbound type1 relation from obj6
                            # or opposite reading - obj6 has outbound type1 relation to obj5

                            # It's the same as next below
  obj6:
    title: Object 6
    color: firebrick
    hex:
      obj5: type1

  # These two last in-ttl relation declarations are good to coexist and will be treated by Hexagon
  # as one relation
  # If happend that one of two declarations type label is changed Hexagon will treat them as
  # two different codirected relations between same two objects and will throgh warning
  

