
hexF:  

  # nodes: >
  #     (
  #       /* TBD: Get ttl translated from other schemas */
  #       $translatedTTL:= {};

  #       $originalTTL:= $$.ttl;
  #       $rawTTL:= $merge([$originalTTL, $translatedTTL]);

  #       $each($rawTTL, function($v, $k) {
  #         { "id": $k,
  #           "body": $v
  #         }
  #       })
  #     )





  query: >
    (
      $query:= $.query;
      $map($query, function($v) {
        {"source": $v, "type": $type($v)}
      })

    )

  getBrackets: >
    (
      $string:= $.str;
      $string != null and $string != ""? (    
        $getBrackets:= function($str) {(
          $iter:= function($str, $arr, $i) {(
          /*/(\(([^()]|(?R))*\))/*/ /**/
            $nestest:= $match($str, /\([\$\[\]0-9a-zA-Z!_+-| ]+\)/);
            $count($nestest)>0 ? $iter($replace($str, /\([\$\[\]0-9a-zA-Z!_+-| ]+\)/, "$arr[" & $i & "]", 1), $append($arr, $replace($nestest[0].match, /[()]/, "")), $i+1) : $append($arr, $str)
          )};
          $iter($str, [], 0)
        )};
        $getBrackets($string);
      ) : []
    )

  calcView: >
    (
      $edges:= $eval($$.hexF.edges);
      $str1:= "((id and id) or (id and !id)) and id";
      $str2:= "process and beryozka_arch";
      $str3:= "radio_details";
      $str4:= "(radio_details)";
      $str5:= "( radio_details )";
      $str6:= "radio_program or tf_am";
      $str7:= "(radio_program or tf_pm) and (broadcasting or radio_details)";
      $str8:= "( radio_program or tf_am )";

      $brackets:= $eval($$.hexF.getBrackets, {"str": $str7}); $log($brackets, "brackets");
      $expr:= $map($brackets, function($v) {(
        $op:= $match($v, / and | or /).match; /*-[\[0-9a-zA-Z_ \]]*->*/
        $op ?
        (
          $args:= $split($v, $op); $log($args, "LR");
          
          $left:= $substring($args[0],0,1)="!" ?
              ( 
              $count($match($substringAfter($replace($args[0], " ", ""), "!"), /\$arr\[[0-9]\]/)) > 0 ? 
                $match($substringAfter($replace($args[0], " ", ""), "!"), /\$arr\[[0-9]\]/).match :
                "$edges[$not($.target = '" & $substringAfter($replace($args[0], " ", ""), "!") & "' and $.label = 'map')].source";
              ) : (
              $count($match($replace($args[0], " ", ""), /\$arr\[[0-9]\]/)) > 0 ?
                $match($replace($args[0], " ", ""), /\$arr\[[0-9]\]/).match :
                "$edges[$.target = '" & $replace($args[0], " ", "") & "' and $.label = 'map'].source";
              ); $log($count($match($replace($args[0], " ", ""), /\$arr\[[0-9]\]/)), "match");
          
          $right:= $substring($args[1],0,1)="!" ? 
              ( 
              $count($match($substringAfter($replace($args[1], " ", ""), "!"), /\$arr\[[0-9]\]/)) > 0 ? 
                $match($substringAfter($replace($args[1], " ", ""), "!"), /\$arr\[[0-9]\]/).match :
                "$edges[$not($.target = '" & $substringAfter($replace($args[1], " ", ""), "!") & "' and $.label = 'map')].source";
              ) : (
              $count($match($replace($args[1], " ", ""), /\$arr\[[0-9]\]/)) > 0 ?
                $match($replace($args[1], " ", ""), /\$arr\[[0-9]\]/).match :
                "$edges[$.target = '" & $replace($args[1], " ", "") & "' and $.label = 'map'].source";
              );
          $op = " and " ? $left & "[$ in " & $right & "]" : "$append(" & $left & "," & $right & ")"; /*$match($op, /-[\[0-9a-zA-Z_ \]]*->/) ? ($log($op, "pass");"$edges[$.source = '" & $left & "' and $.target = '" & $right & "'].$append($source, $target)")*/
        ) :
          $substring($v,0,1)="!" ? 
              ( 
              $count($match($substringAfter($replace($v, " ", ""), "!"), /\$arr\[[0-9]\]/)) > 0 ? 
                $match($substringAfter($replace($v, " ", ""), "!"), /\$arr\[[0-9]\]/).match :
                "$edges[$not($.target = '" & $substringAfter($replace($v, " ", ""), "!") & "' and $.label = 'map')].source";
              ) : (
              $count($match($substringAfter($replace($v, " ", ""), "!"), /\$arr\[[0-9]\]/)) > 0 ? 
                $match($substringAfter($replace($v, " ", ""), "!"), /\$arr\[[0-9]\]/).match :
                "$edges[$.target = '" & $replace($v, " ", "") & "' and $.label = 'map'].source";
              );

      )});

      $log($expr, "expressions");
      
      $iter:= function($r, $arr, $i) {(
        $arr:= $i = 0 ? [$distinct($eval($r[$i]))] : 
                  $i = 1 ?
                    ( 
                      $r:= $map($r, function($v, $ii) {
                        $ii = 1 ? $replace($v, "$arr[0]", "$arr") : $v
                      });
                      $c:=[0,1];
                      $map($c, function($v) {
                        $v = 0 ? [$arr] : [$distinct($eval($r[$i]))]
                      });
                    ) :
                    (
                      $c:=[0];
                      $map($c, function($v) {(
                        $map($append($arr, ["x"]), function ($v,$ii,$a) {(
                          $ii < $count($a)-1 ? $v : [$distinct($eval($r[$i]))]
                        )});
                      )});

                    );
        $log($arr, "total");
        /*$arr:= $append($arr, $eval($r[$i]));$log($r[$i]);*/
        $i != $count($r)-1 ? $iter($r, $arr, $i+1) : $arr
      )};
      $res:= $count($expr) > 0 ? $iter($expr,[], 0): [];



    )

  condition_samples: >
    (
      $edges:= $eval($$.hexF.edges);

      /*(a: process)*/ $a:= $edges[$.target = "process" and $.label = "map"].source; $log($a, "processes");
      /*let a = any objects which have map rel to process (a)-[map]->({id="process"})*/

      /*(b: beryozka_arch)*/ $b:= $edges[$.target = "beryozka_arch" and $.label = "map"].source; $log($b, "beryozka");
      
      /*(c: process and beryozka_arch) -- excessive*/ $c:= $distinct($edges[$.source in $a and $.source in $b].source); $log($c, "beryozka processes");
      /*(c1: process and beryozka_arch)*/ $c1:= $a[$ in $b]; $log($c1, "beryozka processes (alt)");
      /*let c1 = any objects which have map rels to process and beryozka_arch*/
      /*(c2: process, beryozka_arch)*/ $c2:= $edges[$.target = "process" and $.label = "map"].source[$ in $edges[$.target = "beryozka_arch" and $.label = "map"].source]; $log($c2, "beryozka processes (from scratch)");

      /*or not*/ /*modes*/

      /*this clause is OR by default*/
      /*(a: ((id and id) or (id and !id)) and [id(mode array)])*/ /*mode array returns id??? and can be hierarchical. May be it should be separated from conditions and injects by variables*/
      /*(b: id and [id])*/




      /*(d: event)*/ $d:= $edges[$.target = "event" and $.label = "map"].source; $log($d, "events");
      
      /*(c)-->(d)*/ $d3:= $distinct($edges[$.target in $d and $.source in $c].target); $log($d3, "events resulted from beryozka processes");
      /*(d)-->(c)*/ $d4:= $distinct($edges[$.target in $c and $.source in $d].source); $log($d4, "events triggering beryozka processes");
      
      /*(d)-->(c) or (c)-->(d)*/ $d1:= $distinct($append($d3, $d4)); $log($d1, "events related to beryozka processes");
      
      /*(c)-->(d)-->(c)*/ $d2:= $d3[$ in $d4]; $log($d2, "internal beryozka processes events");


    )

  derived: >
      (
        $edges:= $eval($$.hex.getEdges);

        $events:= $edges[($.target = "event" and $.label = "map") or ($.source = "event" and $.label = "include") ].source;
        /*$bss:= $edges[($.target = "bs" and $.label = "map") or ($.source = "bs" and $.label = "include")].source;*/
        $procs:= $edges[($.target = "process" and $.label = "map") or ($.source = "process" and $.label = "include")].source;
        $caps:= $edges[($.target = "capability" and $.label = "map") or ($.source = "capability" and $.label = "include")].source;$log($caps);
        /*$bssCapped:= $edges[$.source in $bss and $.target in $caps];  $log($bssCapped);*/
        $procsCapped:= $edges[$.source in $procs and $.target in $caps];
        /*
        $bssByCaps:= $map($distinct($bssCapped.target), function($v)  {(
          {"cap": $v,
           "bss": $bssCapped[$.target = $v].source
          }
        )});
        */
        $procsByCaps:= $map($distinct($procsCapped.target), function($v)  {(
          {"cap": $v,
           "procs": $procsCapped[$.target = $v].source
          }
        )});
        /*
        $derived:= $map($bssByCaps, function($v) {(
          $ev_cap:= $edges[$.source in $events and $.target in $v.bss];
          $cap_ev:= $edges[$.source in $v.bss and $.target in $events];
          {"in":
            $map($ev_cap, function($vv) {(
              $not($vv.source in $cap_ev.target) ? {"source":$vv.source, "target": $v.cap, "label": "init"}
            )}),
          "out":
            $map($cap_ev, function($vv) {(
              $not($vv.target in $ev_cap.target) ? {"source": $v.cap, "target": $vv.target, "label": "res"}
            )})
          }
        )});
        */
        $derived:= $map($procsByCaps, function($v) {(
          $ev_cap:= $edges[$.source in $events and $.target in $v.procs];
          $cap_ev:= $edges[$.source in $v.procs and $.target in $events];
          {"in":
            $map($ev_cap, function($vv) {(
              $not($vv.source in $cap_ev.target) ? {"source":$vv.source, "target": $v.cap, "label": "init"}
            )}),
          "out":
            $map($cap_ev, function($vv) {(
              $not($vv.target in $ev_cap.target) ? {"source": $v.cap, "target": $vv.target, "label": "res"}
            )})
          }
        )});

        $derived:= $append($derived.in, $derived.out);

      )

entities:

  models:
    presentations:


condition: >
  (
      viewpoint:
        hex:
          n1: include #----------
          n2: include # pattern
          n3: include #----------
          m1: mode #-------------
          m2: mode # independent 1st level selectors
          m3: mode #-------------
          M: mode     #-mode tree-
                      #-no_modes by default as last mode
      
      mx: do smth with nx
        hex:
          excludes nodes
          excludes edges
          excludes nodes by relations condition or/and attributes values
          adds derived relations being triggered by node+node pair
          includes next level modes
      
      M: (var1)
        hex:
          - title: 
            hex:
          - title:
            hex:
          
      M: (var2)
        hex:
          - m1: mode
          - m2: mode

      Получается запросы идут только лишь в листах дерева модов. Моды - это просто пользовательские селекторы
      Но тогда и смысл построения L1 по мапам пропадает? Блинский

      Параметризация нужна для пользовательских слайсов. Их иногда нужно иметь несколько (dim, modes)
      Нужно какое-то отображение паттерна (с добавленными тэгами, условиями и, возможно, неймспейсами и дубликатами)
      Дериватив - это тоже запрос, проверка результата и создание элемента (в рамках запроса или нет, пока не знаю)
      hexQ:
        - (a)
        - (b: tag)
        - (a)-[c]->(b)
        - (b)-x[d: label]->(e: tag)
        - (a: +tag)
        - (f: [id=tag])
        - x(g: [id=$tag])????
        - or:
          -
          - and:
            -
            -
        - and
          -
          -
        - return
          - a
          - e
          - exclude: or move this section in vp (now because of queries usage)
            - rel (between or labeled)
            - node or tag

      $a:= $eval($$.hex.getNodes)[$.*.hex.process = "map"]; /*(a:process)*/ $log($a);
      $b:= $eval($$.hex.getNodes)[$.*.hex.event = "map"]; /*(b:event)*/ $log($b);

      $c:= $eval($$.hex.getEdges)[$.source in $b.id and $.target in $a.id]; /*(b)-[c]->(a) return c*/
      $a:= $eval($$.hex.getNodes, {"ctx": $c.target}); /*(b)-[c]->(a) return a*/
      $b:= $eval($$.hex.getNodes, {"ctx": $c.source}); /*(b)-[c]->(a) | & ! return b*/
      /*(a)-[d]->(e: event)*/
      /*(a)-x[d:result]->(e: event)*/
      /*(a:+arch)*/



      /*($arch)*/

  )
# ttl:

#   mm:
#     menu:
#       - presentation: pattern (shows that e-cap is derived)
#       - presentation: view (tries to get derived rels for EVERY pair e-cap OR for every event is it has derived rel to any cap)
#     hex:
#       event: include
#       capability: include
  
#   event:
#     hex:
#       capability: initiates.derived_from_rule

#   capability:
#     hex:
#       event: results.derived_from_rule


#   event1:

#   capability1:

#   rule1:
#     event


# # QUANTITIFY

# obj1:
#   attr_a: val (originated in obj1)
#   attr_b: val (originated in obj1)
#   hex:
#     obj2: "rel (obj2 get attribute rel: obj1)"

# obj2:
#   attr_c: val

# # obj2.rel = obj1  

#  # Eсли объект 1 тоже имеет входы от других объектов, то мы получим "весь граф в каждом объекте"
#  # значит объект может использовать значения только neighbours originated


# ttl:
#   vp1:
#     title: Viewpoint 1
#     side:
#       - item: Viewpoint 1
#         presentation: view
#     hex:
#       patTag2: include

#   patTag1:
#     title: Tag in Pattern 1
#     hex:
#       vp1: map

#   patTag2:
#     title: Tag in Pattern 2



#   # condition tests (radio)

#   broadcasting:
#     title: Радиовещание

#   radio_details:
#     title: радио детали

#   radio_receiver:
#     title: радио приемник
#     hex: 
#       broadcasting: map

#   antenna:
#     title: Антена
#     hex: 
#       radio_details: map

#   amplifier:
#     title: усилитель
#     hex: 
#       radio_details: map

#   radio_speaker:
#     title: Динамик
#     hex: 
#       radio_details: map

#   radio_station:
#     title: радио-станция
#     hex: 
#       broadcasting: map

#   radio_translation:
#     title: радио-трансляция
#     hex: 
#       broadcasting: map

#   radio_program:
#     title: радио-программа
#     hex: 
#       broadcasting: map

#   radio_listener:
#     title: Слушатель
#     hex: 
#       broadcasting: map

#   KBE:
#     title: KBE
#     hex:
#       radio_station: map

#   DFG:
#     title: DFG
#     hex:
#       radio_station: map

#   time_frame:
#     title: Временной промежуток

#   tf_am:
#     title: AM
#     hex:
#       time_frame: map

#   tf_pm:
#     title: PM
#     hex:
#       time_frame: map

#   program1:
#     title: Программа 1
#     hex:
#       radio_program: map
#       tf_am: map
#       tf_pm: map
#       KBE: map
#       DFG: map

#   program2:
#     title: Программа 2
#     hex:
#       radio_program: map
#       tf_pm: map
#       DFG: map
#       broadcasting: map
   


# hexQ:
#   query1:
#     - (a)
#     - (b:tag)
#     - (a)-[c]->(b)
#     - (b)-x[d:label]->(e:tag)
#     - (a:+tag)
#     - (f:[id=tag])
#     - x(g:[id=$tag])
#     - or:
#       -
#       - and:
#         -
#         -
#     - and:
#       -
#       -
#     - return:
#       - a
#       - e
#       - exclude: #or move this section in vp (now because of queries usage)
#         - rel (between or labeled)
#         - node or tag



