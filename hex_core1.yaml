








imports:
  - articles/articles.yaml

  - derivatives.yaml


entities:

  articles:
    title: Articles
    menu: |
      (
        $append([
            {
              "title": 'Articles',
              "location": 'Hexagon/Материалы',
              "expand": true,
              "icon": ''
            }
          ],
          articles.$spread().(
              *.location ? {
                  "location": "Hexagon/Материалы/" & *.location,
                  "link": "entities/articles/blank?id=" & $keys()[0]
              }
          )
        )
      )
    schema:
      type: object
      patternProperties:
        ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
          oneOf:
            - type: object
              properties:
                title:
                  title: Название документа
                  type: string
                location:
                  title: Место расположения в меню
                  type: string
                icon:
                  title: Иконка в меню
                  type: string
                type:
                  title: Тип документа
                  type: string
                subjects:
                  title: Принадлежит объектам
                  type: array
                  items:
                    type: string
                source:
                  title: Источник данный (запрос или dataset)
                  type: string
                  oneOf:
                    - type: string
                      title: Идентификатор dataset
                      pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
                    - type: string
                      title: JSONata запрос
                      pattern: \s*\((.|\s)*\)\s*
              required:
                - source
            - type: object
              properties:
                title:
                  title: Название документа
                  type: string
                location:
                  title: Место расположения в меню
                  type: string
                icon:
                  title: Иконка в меню
                  type: string
                type:
                  title: Тип документа
                  type: string
                subjects:
                  title: Принадлежит объектам
                  type: array
                  items:
                    type: string
                template:
                  title: Путь к файлу шаблона
                  type: string
                source:
                  title: Данные для шаблона
                  type: string
                  oneOf:
                    - type: string
                      title: Идентификатор dataset
                      pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
                    - type: string
                      title: JSONata запрос
                      pattern: \s*\((.|\s)*\)\s*
              required:
                - template
                - source
      additionalProperties: false
    presentations:
      blank:
        title: Представление документа
        params:
          title: Требуемые параметры для презентации
          type: object
          properties:
            id:
              title: Идентификатор документа
              type: string
              pattern: ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$
          required:
            - id
        $constructor: |
          (
            /* Получаем объект документа */ 
            $doc := $lookup($$.articles, $params."id");
            /* Для рендера берем за основу объект документа */
            $merge([$doc, (
              {
                "$base": "/articles/" & $params."id"
              }
            )])
          )

  hexV:

    menu: >
      (
        $ttlMenu:= []; /*placeholder for ttl control menu items*/

        $menu:= $map($eval($$.hexF.nodes)[$.body.side != null], function($v) {(
                                  $map($v.body.side, function($vv) {
                                    { "link": "/entities/hexV/" & $vv.presentation & "?id=" & $v.id,
                                      "location": "hex 1.0/Views/" & $vv.item
                                    }
                                  })
        )});
        $menu:= $reduce($menu, $append);

        $append($ttlMenu, $menu)
      )

    presentations:
      view:
        type: markdown
        template: view.md

        source: >
          (
            $viewConfig:= $params.id;
            $va_id:= $substringBefore($viewConfig, ".");
            $modes_inUse:= $substringBefore($substringAfter($viewConfig, "."), ".");
            $modes_select:= $substringAfter($substringAfter($viewConfig, "."), ".");
            $body:= $eval($$.hexF.nodes)[$.id = $va_id].body;

            $va_exists:= $body ? true : false;
            $modes_avail:= $keys($spread($body.hex)[$.* = "modes"])[$exists($lookup($$.hexModes, $))];
            $modes_inUse_exist:= $modes_inUse in $modes_avail ? true : false;
            $modes_avail:= $modes_inUse_exist ? 
                  $map($modes_avail, function($v) {$v != $modes_inUse ? {"id": $v, "title": $$.hexModes.$eval($v).title} : {"id": $v, "title": $$.hexModes.$eval($v).title, "active": true}})
                   : 
                  $map($modes_avail, function($v) {{"id": $v, "title": $$.hexModes.$eval($v).title}});
            $modes_avail:= $modes_avail~>|$[-1]|{"last": true}|;

            $va_exists ? 
              ( 
                $modes_inUse_exist ?
                  (
                    /*$modes_tree:= $eval($$.hexF.getModes,  {"id": $modes_inUse, "active": $modes_select});*/

                    $modes_tree:= [
                        {"prefix": "byColor", "branch": [{"id": "dh", "title": "DH", "active": true}, {"id": "df", "title": "DF", "last": true}]},
                        {"prefix": "byColor.first", "branch": [{"id": "gh", "title": "GH" }, {"id": "gf", "title": "GF", "last": true, "active": true}]}
                        ];


                    {"va": $va_id, "body": $body, "modes_avail_show": $count($modes_avail), "modes_avail": $modes_avail, "modes_tree": $modes_tree, "patternParams": "id=" & $va_id & "." & $modes_inUse & "." & modes_select}
                  )
                : {"va": $va_id, "body": $body, "modes_avail_show": $count($modes_avail), "modes_avail": $modes_avail, "patternParams": "id=" & $va_id}
              )

            : {"va": $va_id, "error": true};


          )

      pattern:
        type: markdown

      l1:
        type: PlantUml
        template: pattern_graph.puml
        source: >
          (
            $viewConfig:= $params.id;
            $va_id:= $substringBefore($viewConfig, ".");
            $modes:= $substringBefore($substringAfter($viewConfig, "."), ".");
            $modes_select:= $substringAfter($substringAfter($viewConfig, "."), ".");
            
            $eval($$.hexF.l1, {"ctx": $va_id})
          )

      l2:
        type: PlantUml

  lake:
    menu: >
      (
        $treePaths:= function($nested, $items, $i, $path) {(
          $path:= $nested[$i] ? $path & "/" & $nested[$i].title; $log($path, $i);
          $items:= $count($nested[$i].includes) > 0 ?
            $append($items, $treePaths($nested[$i].includes, [], 0, $path)): 
            $append( $items, {"location": $path, "link":$nested[$i].link});
          $i<$count($nested)-1 ? $treePaths($nested, $items, $i+1, $substringBefore($path, "/" & $nested[$i].title)) : $items
        )}; 
        $log($$.hexNav);
        $menu:= $treePaths($$.hexNav, [{"location": "Hexagon", "link": "/entities/articles/blank?id=hex_main"}], 0, "Hexagon");
      )


    presentations:


      tags:
        type: markdown
        template: tags.md
        source: >
          (

          )

      tags_graph:
        type: PlantUml
        template: tags_graph.puml
        source: >
          (
            $edges:= $eval($$.hex.edgesMaps, {"edges": $eval($$.hex.getEdges)});
            $edges:= $edges[$.source in $edges.target];
            $tops:= $edges[$not($.target in $edges.source)].target;
            $nodes:= $distinct($append($edges.source, $edges.target))[$not($ in $tops)];
            {"tops": $tops, "nodes": $nodes, "edges": $edges}

          
          )

      whole_landscape:
        type: markdown
        template: w_landscape.md
        source: >
          (
            $exp:= $params.expansion;

            {"exp": $exp}
          )

      traverse_graph:
        type: PlantUml
        template: traverse_graph.puml
        source: >
          (
            $expansion:= $params.expansion;

            $nodes:=  $eval($$.hexF.nodes);
            $edges:= $eval($$.hexF.edges);
            $maps:= $edges[$.label = "map"];

            /* Tops are nodes which have mappings from others to them, but have no mappings to others */
            $tops:= $distinct($maps[$not($.target in $maps.source)].target);
            $tops:= $nodes[$.id in $tops];

            $tops:= $map($tops, function($v) {
              $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
            });

            $tops_count:= $count($tops) = 0 ? "0" : $count($tops);

            /* Leafs here are nodes which have nor to or from mappings */
            $leafs:= $nodes.id[$not($ in $maps.target) and $not($ in $maps.source)];
            $leafs_count:= $count($leafs) = 0 ? "0" : $count($leafs);
                
            $levels:= $expansion != "" ?
              (    
                $exp_path:= $split($expansion, ".");$log($exp_path);
                $exp_path_deep:= $exp_path != "" ? $count($exp_path): 0;$log($exp_path_deep);

                $exp_path_deep > 0 ? 
                    $map($exp_path, function($v, $i) {(
                      $log($exp_path_deep, "check");
                      $url_tail_calc:= function($arr, $ii, $url) {(
                        $url:= $url & $arr[$ii] & ".";
                        $ii < $i ? $url_tail_calc($arr, $ii+1, $url) : $url
                      )}; 
                      $url_tail:= $url_tail_calc($exp_path, 0, "");
                      $maps:= $edges[$.target = $v and $.label="map"];
                      $members:= $maps.source;
                      $leafs:= $members[$not($ in $edges[$.label = "map"].target)];
                      $members:= $members[$not($ in $leafs)];

                      $leafs:= $nodes[$.id in $leafs];
                      $members:= $nodes[$.id in $members];

                      $members:= $map($members, function($v) {
                        $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
                      });

                      $leafs_count:= $count($leafs)=0 ? "0" : $count($leafs);
                      $members_count:= $count($members)=0 ? "0" : $count($members);

                      {"id": "l" & $string($i+1),
                       "title": "level " & $string($i+1),
                       "members": $members, 
                       "members_count": $members_count, 
                       "leafs": {"id": "leafs" & $i, "title": "Leafs"},
                       "leafs_count": $leafs_count, 
                       "maps": $maps[$.source in $members.id], 
                       "url": $$.hexEnv.url & "entities/lake/whole_landscape?expansion=" & $url_tail}
                    )});
              );



            {"tops": $tops,
             "tops_count": $tops_count,
             "leafs": {"id": "leafs", "title": "Leafs"},
             "leafs_count": $leafs_count,
             "levels": $levels,
             "url": $$.hexEnv.url & "entities/lake/whole_landscape?expansion="
            }
          
          )


  hexQ:

    menu: >
      (

        $menu:= $map($keys($$.hexQ), function($v) {
                                    { "link": "/entities/hexQ/query?id=" & $v,
                                      "location": "hexQ/" & $lookup(hexQ, $v).title
                                    }
                                  })

      )

    presentations:
      query:
        type: markdown
        template: query.md

        source: >
          (
            $qId:= $params.id;
            $body:= $lookup(hexQ, $qId);
            $qRes:= $eval($$.hexF.query, {"qId": $qId}).response;
            {"qId": $qId, "body": $body, "response": $qRes}
          )

      query_graph:
        type: PlantUml
        template: query_graph.puml

        source: >
          (
            $qId:= $params.id;
            {"tags": $eval($$.hexF.query2, {"qId": $qId}).pattern};
          )



hexF:

  nodes: >
      (
        /* TBD: Get ttl translated from other schemas */
        $translatedTTL:= {};

        $originalTTL:= $$.ttl;
        $rawTTL:= $merge([$originalTTL, $translatedTTL]);

        /* Actually there is no need to break long titles globally*/
        $each($rawTTL, function($v, $k) {
          { "id": $k,
            "body": $v
          }
        });
      )


  # creates internal edge-objects from all available ttl_objects definitions
  # removes reverse modifier '(<)' from label and interchange source and target respectively
  # depends on: nodes
  # results to: [{"source": obj_id, "target": obj_id, "label": label | null}, ...]
  # call: $eval($$.hexF.edges);
  edges: > 
    (
      $nodes:= $eval($$.hexF.nodes);
      $edges:= $map($nodes, function($v) {
        $map($spread($v.body.hex), function($vv) {(

            /* (<) modifier in labels )*/
            /*
            $match($vv.* != null ? $vv.* : "", /\(\<\)/) ?
                {"source": $keys($vv), "target": $v.id, "label": $replace($vv.*,/\(\<\)/, "")} :
                {"source": $v.id, "target": $keys($vv), "label": $vv.*}
            )})
            */

            /* (<) modifier in keys )*/
            $match($keys($vv), /\(\<\)/) ?
                {"source": $replace($keys($vv), /\(\<\)/, ""), "target": $v.id, "label": $vv.*} :
                {"source": $v.id, "target": $keys($vv), "label": $vv.*}
            )})

      });
      $edges:= $distinct($reduce($edges, $append));
    )

  l1: >
    (
      $l0:= $.ctx;

      $edges:= $eval($$.hexF.edges);
      $l1NodesId:= $edges[$.target = $l0 and $.label = "map"].source;
      $l1Regs:= $edges[$.source in $l1NodesId and $.target in $l1NodesId];
      $l1Nodes:= $eval($$.hexF.nodes)[$.id in $l1NodesId];

      $l1Nodes:= $map($l1Nodes, function($v) {
        $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
      });


      $res:= {"l1Nodes": $l1Nodes, "l1Regs": $l1Regs}
    
    )

  getModes: >
    (
      $modes_id:= $.id;
      $selection:= $.active;
      $selection:= $selection = "" ? "0"

      $modes_id:= "bySize";
      $selection:= "1.0";

      $modes:= $lookup($$.hexModes, $modes_id);

      $build_tree:= function ($root, $path, $lev, $arr) {(
      $path:= $path[$lev] ? $append($path, "0") : $path;
      $log($root, "iter");
        $arr:= $append($arr,$root?
          (
            $prefix:= $lev=0 ? $modes_id : $modes_id & "." & $join($path[0-$lev], ".");

            $branch:= $map($root, function($v, $i) {(
              {"id": $i, "title": $v.title, "active": $exists($path[$lev]) and $number($path[$lev])=$i ? true : $i=0 ? true , "includes": $v.includes ? $v.includes}
            )});

            {"prefix": $prefix, "branch": $branch}
          )
            :
          $arr);
        $log($arr, "after iter"); $log($arr[$path[$lev]].branch, "row");
        $has_includes:= $map($arr[$path[$lev]].branch, function($v, $i) {(
            $log($path[$lev], "folder");
          $i = $number($path[$lev]) and $v.includes ? $v.includes
        )});$log($has_includes, "drill down");

        $count($has_includes) > 0 ? $build_tree($has_includes, $path, $lev+1, $arr~>|$[$path[$lev]].branch|{}, ["includes"]|) : $arr;
        
      )};

      $tree:= $build_tree ($modes.includes, $split($selection, "."), 0, [])

      /*
      $modes:= $type($modes) = "object" ?

        (
          $modes.* = "(@)enum" ? 
            (
              $modesL1:= $eval($$.hexF.l1, {"ctx": $keys($modes)});
              $map($modesL1.l1Nodes, function($v, $i) {(
                  {"title": $v.body.title, $v.id: "only", "active": $active_mode ? ($v.id = $active_mode ? true : false) : $i = 0 ? true : false}
              )});
            ) : null
        ) : $type($modes) = "array" ?

        (
        
        
        );
      */
    )

hexNav:
  - title: Dashboards
    link: 
    params:
    includes:
      - title: Traverse tags
        link: "/entities/lake/whole_landscape"
      - title: Menu


        # $treePaths:= function($nested, $items, $i, $path) {(
        #   $path:= $nested[$i] ? $path & "/" & $nested[$i].title; $log($path, $i);
        #   $items:= $count($nested[$i].includes) > 0 ?
        #     $append($items, $treePaths($nested[$i].includes, [], 0, $path)): 
        #     $append( $items, {"location": $path, "link":$nested[$i].link});
        #   $i<$count($nested)-1 ? $treePaths($nested, $items, $i+1, "") : $items
        # )}; 
        # $log($$.hexNav);
        # $menu:= $treePaths($$.hexNav, [], 0, "");
      
hexModes:

  byColor:
    title: По цвету
    color: (@)enum

  bySize: 
    title: По размеру
    description: gtturucryc
    includes:
      - title: Большие
        description: ugtgtyf
        big: only
      - title: Средние
        description: inibibu
        medium: only
        includes:
          - title: Новые
            old_packs: exclude
          - title: Старые
            new_packs: exclude 
      - title: Малые
        description: jhbfvdtcrsxex hgcdcr
        small: only
        includes:
          shape: enum

  singleMode:
    - title: 

  # enum  



articles:
  test_article:
    location: test art
    description: Hexagon docs entry point
    type: markdown
    source: articles/ecosystem_main.md
    icon: 'library_books'
