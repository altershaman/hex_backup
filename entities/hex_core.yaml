  

entities:

  seaf.ba.ttl:
    schema:
      type: object
      patternProperties:
        ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
          properties:
            title:
              title: object title
              description: human given name
              type: string
            description:
              title: short description
              description: One to three sentences with no structural formatting
              type: string
          required:
            - title

  hexV:

    # menu: >
    #   ( /*
    #     $seaf.ba.ttlMenu:= []; /*placeholder for seaf.ba.ttl control menu items*/

    #     $menu:= $map($eval($$.hexF.nodes)[$.body.side != null], function($v) {(
    #                               $map($v.body.side, function($vv) {
    #                                 { "link": "/entities/hexV/" & $vv.presentation & "?id=" & $v.id,
    #                                   "location": "hex 1.0/Views/" & $vv.item
    #                                 }
    #                               })
    #     )});
    #     $menu:= $reduce($menu, $append);

    #     $append($seaf.ba.ttlMenu, $menu)
    #     */
    #   )

    presentations:
      view:
        type: markdown
        template: templates/view.md
        source: >
          (
            /*link: ...view?id=vId&mode=mode_x.mode_y*/
            $vId:= $params.id; $modes_selected:= $params.mode;
            $modes_selected:= $split($modes_selected, ".");$log($modes_selected);

            $view:= $lookup($$."seaf.ba.ttl", $vId);
            $view.hexV ?
              (
                $count($view.hexV) = 0 ? {"error": "Object **" & $vId & "** has empty view configuration (hexV)"} :
                $count($view.hexV) > 0 ? 
                  (
                    $chunks:= $distinct($view.hexV.**.modes.%.{"h": $.title, "l": $.modes.title}); $log($chunks);
                    $patternPre:= $count($chunks) > 0 ? 
                      (
                        $chunks:= $map($chunks, function($v) {
                          $map($v.l, function($vv) {($log("", $v &" ", $vv);
                            {"source": $v.h ? $v.h : "viewRoot", "target": $vv, "label": "moded"}
                          )})
                        });$log($chunks);
                        $chains:= $eval($$.hexF.getChains, {"edges": $reduce($chunks, $append)});
                        $maxChain:= function($max, $v) {$count($v.path) > $max ? $count($v.path) : $max};
                        $v_dim:= $reduce($chains, $maxChain, 0);$log($chains, "chains");
                        $leveling:= function($chains, $ci, $v_dim, $matrix) {(
                          $level:= $map($chains, function($v){( $log($v);
                            $ch:= $map($v.path[[0..$ci]], function($vv){$vv != "viewRoot" and $vv != "moded" ? $vv});
                            $v.path[$ci] ? {"chain": $ch, "b": $v.path[$ci-2], "l":$v.path[$ci]} : null
                          )});
                          $matrix:= $append($matrix, {"lev_" & $ci/2:$distinct($level)[$ != null]});
                          $ci< $v_dim-1 ? $leveling($chains, $ci+2, $v_dim, $matrix) : $matrix;
                        )};
                        $modes:= $leveling($chains, 2, $v_dim, []);$log($modes, "modes aval");
                        $modes:= $map($modes, function($v, $i) {(
                          $row:= $map($v.*, function($vv) {
                            $vv.b = "viewRoot" or $vv.b = $modes_selected[$i-1] ? 
                              {"level": $eval($replace($keys($v), "lev_", "")), "chain": $encodeUrl($join($vv.chain, ".")), "b": $vv.b, "title": $vv.l, "selected": $vv.l = $modes_selected[$i] ? true : false}
                          });
                          $row ? (true in $row.selected ? {"row": $row} : {"row": $row~>|$[0]|{"selected": true}|})
                        )});
                        $assemblyMode:= $modes.**.selected[$=true].%.title; $log($assemblyMode);
                        $patternNodes:= $keys($merge($view.**.hexV.%[$.title in $assemblyMode].hexV)); $log($patternNodes);
                        {"vId": $vId, "body": $view~>|$|{}, ["hexV"]|, "modes": $modes, "patternPre": $patternNodes}
                      ) : {"vId": $vId, "body": $view~>|$|{}, ["hexV"]|, "patternPre": $keys($view.hexV)};

                    $patternPre:= $patternPre~>|$|{"patternPre": $append($.patternPre, [{"hexR": $patternPre.modes ? $view.hexV.modes.**[$.title=$patternPre.modes.*[$.selected].title].hexV.hexR : $view.hexV.hexR}])}|;
                    $r:= $eval($$.hexF.resolveView, {"patternPre": $patternPre.patternPre});
                    $patternPre~>|$|{"resView": {"pattern": $encodeUrl($string($r.pattern)), "landscape": $encodeUrl($string($r.landscape))}}, ["patternPre"]|

                  ) 
              ) :
              {"error": "Object **" & $vId & "** has no view configuration (hexV)"}
          )

      pattern_graph:
        type: PlantUml
        template: templates/pattern_graph.puml
        source: >
          (
            $str:= $params.data;
            $data:= $eval($decodeUrl($str));
          )

      landscape_graph:
        type: PlantUml
        template: templates/landscape_graph.puml
        source: >
          (
            $str:= $params.data;
            $data:= $eval($decodeUrl($str));
          )
          
  articles:
    title: Articles
    menu: |
      (
        $append([
            {
              "title": 'Articles',
              "location": 'Hexagon/Материалы',
              "expand": true,
              "icon": ''
            }
          ],
          $$.docs.$spread().(
              *.hex_location ? {
                  "location": "Hexagon/Материалы/" & *.hex_location,
                  "link": "entities/docs/blank?dh-doc-id=" & $keys()[0]
              }
          )
        )
      )
    # schema:
    #   type: object
    #   patternProperties:
    #     ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
    #       oneOf:
    #         - type: object
    #           properties:
    #             title:
    #               title: Название документа
    #               type: string
    #             location:
    #               title: Место расположения в меню
    #               type: string
    #             icon:
    #               title: Иконка в меню
    #               type: string
    #             type:
    #               title: Тип документа
    #               type: string
    #             subjects:
    #               title: Принадлежит объектам
    #               type: array
    #               items:
    #                 type: string
    #             source:
    #               title: Источник данный (запрос или dataset)
    #               type: string
    #               oneOf:
    #                 - type: string
    #                   title: Идентификатор dataset
    #                   pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
    #                 - type: string
    #                   title: JSONata запрос
    #                   pattern: \s*\((.|\s)*\)\s*
    #           required:
    #             - source
    #         - type: object
    #           properties:
    #             title:
    #               title: Название документа
    #               type: string
    #             location:
    #               title: Место расположения в меню
    #               type: string
    #             icon:
    #               title: Иконка в меню
    #               type: string
    #             type:
    #               title: Тип документа
    #               type: string
    #             subjects:
    #               title: Принадлежит объектам
    #               type: array
    #               items:
    #                 type: string
    #             template:
    #               title: Путь к файлу шаблона
    #               type: string
    #             source:
    #               title: Данные для шаблона
    #               type: string
    #               oneOf:
    #                 - type: string
    #                   title: Идентификатор dataset
    #                   pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
    #                 - type: string
    #                   title: JSONata запрос
    #                   pattern: \s*\((.|\s)*\)\s*
    #           required:
    #             - template
    #             - source
    #   additionalProperties: false
    # presentations:
    #   blank:
    #     title: Представление документа
    #     params:
    #       title: Требуемые параметры для презентации
    #       type: object
    #       properties:
    #         id:
    #           title: Идентификатор документа
    #           type: string
    #           pattern: ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$
    #       required:
    #         - id
    #     $constructor: |
    #       (
    #         /* Получаем объект документа */ 
    #         $doc := $lookup($$.articles, $params."id");
    #         /* Для рендера берем за основу объект документа */
    #         $merge([$doc, (
    #           {
    #             "$base": "/articles/" & $params."id"
    #           }
    #         )])
    #       )

  observable:
    # menu: >
    #   (
    #     $treePaths:= function($nested, $items, $i, $path) {(
    #       $path:= $nested[$i] ? $path & "/" & $nested[$i].title; $log($path, $i);
    #       $items:= $nested[$i].link ? $append($items, {"location": $path, "link": $nested[$i].link}): $items;
    #       $items:= $count($nested[$i].includes) > 0 ?
    #         $append($items, $treePaths($nested[$i].includes, [], 0, $path)): 
    #         $append( $items, {"location": $path, "link":$nested[$i].link});
    #       $i<$count($nested)-1 ? $treePaths($nested, $items, $i+1, $substringBefore($path, "/" & $nested[$i].title)) : $items
    #     )}; 
    #     $log($$.hexNav);
    #     $menu:= $treePaths($$.hexNav, [], 0, "Hexagon");
    #   )

    menu: >
      (
        $treePaths:= function($nested, $items, $i, $path) {(
          $path:= $path!="" and $nested[$i] ? $path & "/" & $nested[$i].title : $path="" and $nested[$i] ? $nested[$i].title; $log($path, $i);
          $items:= $nested[$i].link ? $append($items, {"location": $path, "link": $nested[$i].link}): $items;
          $items:= $count($nested[$i].includes) > 0 ?
            $append($items, $treePaths($nested[$i].includes, [], 0, $path)): 
            $items;
          $i<$count($nested)-1 ? $treePaths($nested, $items, $i+1, $substringBefore($path, "/" & $nested[$i].title)) : $items
        )}; 

        $menu:= $reduce($map($$.hexNav, function($v) {(
          $distinct($treePaths($v, [], 0, ""))
        )}), $append)
      )



    presentations:

      bages:
        type: markdown
        template: templates/bages.md
          
      bages_icons:
        type: PlantUml
        template: templates/bages.puml
        source: >
          (
            {"bages": $map($spread($$.hexBages), function($v) {
                        {"bId": $keys($v), "svg": $v.*}
                      })
            }
          )

hexNav:
  - title: Hexagon
    link: "/entities/docs/blank?dh-doc-id=hex_main"
    includes:
      - title: Dashboards
        link: 
        params:
        includes:
          - title: Bages Icons
            link: "entities/observable/bages"

