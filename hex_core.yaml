# Hexagon core entities


imports:
  - articles/articles.yaml
  # - hex_lang/ttl_declaration_el_interm.yaml
  # - hex_lang/ttl_declaration_advanced_1.yaml
  # - hex_lang/ttl_declaration_advanced_2.yaml
  # - hex_lang/hex_declaration.yaml


entities:

  articles:
    title: Articles
    menu: |
      (
        $append([
            {
              "title": 'Articles',
              "location": 'Hexagon/Материалы',
              "expand": true,
              "icon": ''
            }
          ],
          articles.$spread().(
              *.location ? {
                  "location": "Hexagon/Материалы/" & *.location,
                  "link": "entities/articles/blank?id=" & $keys()[0]
              }
          )
        )
      )
    schema:
      type: object
      patternProperties:
        ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
          oneOf:
            - type: object
              properties:
                title:
                  title: Название документа
                  type: string
                location:
                  title: Место расположения в меню
                  type: string
                icon:
                  title: Иконка в меню
                  type: string
                type:
                  title: Тип документа
                  type: string
                subjects:
                  title: Принадлежит объектам
                  type: array
                  items:
                    type: string
                source:
                  title: Источник данный (запрос или dataset)
                  type: string
                  oneOf:
                    - type: string
                      title: Идентификатор dataset
                      pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
                    - type: string
                      title: JSONata запрос
                      pattern: \s*\((.|\s)*\)\s*
              required:
                - source
            - type: object
              properties:
                title:
                  title: Название документа
                  type: string
                location:
                  title: Место расположения в меню
                  type: string
                icon:
                  title: Иконка в меню
                  type: string
                type:
                  title: Тип документа
                  type: string
                subjects:
                  title: Принадлежит объектам
                  type: array
                  items:
                    type: string
                template:
                  title: Путь к файлу шаблона
                  type: string
                source:
                  title: Данные для шаблона
                  type: string
                  oneOf:
                    - type: string
                      title: Идентификатор dataset
                      pattern: ^[0-9a-zA-Z][a-zA-Z0-9 ]*(\.[a-zA-Z][a-zA-Z0-9\_]*)*$
                    - type: string
                      title: JSONata запрос
                      pattern: \s*\((.|\s)*\)\s*
              required:
                - template
                - source
      additionalProperties: false
    presentations:
      blank:
        title: Представление документа
        params:
          title: Требуемые параметры для презентации
          type: object
          properties:
            id:
              title: Идентификатор документа
              type: string
              pattern: ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$
          required:
            - id
        $constructor: |
          (
            /* Получаем объект документа */ 
            $doc := $lookup($$.articles, $params."id");
            /* Для рендера берем за основу объект документа */
            $merge([$doc, (
              {
                "$base": "/articles/" & $params."id"
              }
            )])
          )

  hexV:

    menu: >
      (
        $ttlMenu:= []; /*placeholder for ttl control menu items*/

        $menu:= $map($eval($$.hexF.nodes)[$.body.side != null], function($v) {(
                                  $map($v.body.side, function($vv) {
                                    { "link": "/entities/hexV/" & $vv.presentation & "?id=" & $v.id,
                                      "location": "hex 1.0/Views/" & $vv.item
                                    }
                                  })
        )});
        $menu:= $reduce($menu, $append);

        $append($ttlMenu, $menu)
      )

    presentations:
      view:
        type: markdown
        template: view.md

        source: >
          (
            $viewConfig:= $params.id;
            $va_id:= $substringBefore($viewConfig, ".");
            $modes_inUse:= $substringBefore($substringAfter($viewConfig, "."), ".");
            $modes_select:= $substringAfter($substringAfter($viewConfig, "."), ".");
            $body:= $eval($$.hexF.nodes)[$.id = $va_id].body;

            $va_exists:= $body ? true : false;
            $modes_avail:= $keys($spread($body.hex)[$.* = "modes"])[$exists($lookup($$.hexModes, $))];
            $modes_inUse_exist:= $modes_inUse in $modes_avail ? true : false;
            $modes_avail:= $modes_inUse_exist ? 
                  $map($modes_avail, function($v) {$v != $modes_inUse ? {"id": $v, "title": $$.hexModes.$eval($v).title} : {"id": $v, "title": $$.hexModes.$eval($v).title, "active": true}})
                   : 
                  $map($modes_avail, function($v) {{"id": $v, "title": $$.hexModes.$eval($v).title}});
            $modes_avail:= $modes_avail~>|$[-1]|{"last": true}|;

            $va_exists ? 
              ( 
                $modes_inUse_exist ?
                  (
                    /*$modes_tree:= $eval($$.hexF.getModes,  {"id": $modes_inUse, "active": $modes_select});*/

                    $modes_tree:= [
                        {"prefix": "byColor", "branch": [{"id": "dh", "title": "DH", "active": true}, {"id": "df", "title": "DF", "last": true}]},
                        {"prefix": "byColor.first", "branch": [{"id": "gh", "title": "GH" }, {"id": "gf", "title": "GF", "last": true, "active": true}]}
                        ];


                    {"va": $va_id, "body": $body, "modes_avail_show": $count($modes_avail), "modes_avail": $modes_avail, "modes_tree": $modes_tree, "patternParams": "id=" & $va_id & "." & $modes_inUse & "." & modes_select}
                  )
                : {"va": $va_id, "body": $body, "modes_avail_show": $count($modes_avail), "modes_avail": $modes_avail, "patternParams": "id=" & $va_id}
              )

            : {"va": $va_id, "error": true};


          )

      pattern:
        type: markdown

      l1:
        type: PlantUml
        template: pattern_graph.puml
        source: >
          (
            $viewConfig:= $params.id;
            $va_id:= $substringBefore($viewConfig, ".");
            $modes:= $substringBefore($substringAfter($viewConfig, "."), ".");
            $modes_select:= $substringAfter($substringAfter($viewConfig, "."), ".");
            
            $eval($$.hexF.l1, {"ctx": $va_id})
          )

      l2:
        type: PlantUml

  observable:
    menu: >
      (
        $treePaths:= function($nested, $items, $i, $path) {(
          $path:= $nested[$i] ? $path & "/" & $nested[$i].title; $log($path, $i);
          $items:= $count($nested[$i].includes) > 0 ?
            $append($items, $treePaths($nested[$i].includes, [], 0, $path)): 
            $append( $items, {"location": $path, "link":$nested[$i].link});
          $i<$count($nested)-1 ? $treePaths($nested, $items, $i+1, $substringBefore($path, "/" & $nested[$i].title)) : $items
        )}; 
        $log($$.hexNav);
        $menu:= $treePaths($$.hexNav, [{"location": "Hexagon", "link": "/entities/articles/blank?id=hex_main"}], 0, "Hexagon");
      )


    presentations:


      tags:
        type: markdown
        template: tags.md
        source: >
          (

          )

      tags_graph:
        type: PlantUml
        template: tags_graph.puml
        source: >
          (
            $edges:= $eval($$.hex.edgesMaps, {"edges": $eval($$.hex.getEdges)});
            $edges:= $edges[$.source in $edges.target];
            $tops:= $edges[$not($.target in $edges.source)].target;
            $nodes:= $distinct($append($edges.source, $edges.target))[$not($ in $tops)];
            {"tops": $tops, "nodes": $nodes, "edges": $edges}

          
          )

      traversing:
        type: markdown
        template: traversing.md
        source: >
          (
            $exp:= $params.expansion;

            {"exp": $exp}
          )

      traverse_graph:
        type: PlantUml
        template: traverse_graph.puml
        source: >
          (

            /*          
            $expansion:= $params.expansion;

            $nodes:=  $eval($$.hexF.nodes);
            $edges:= $eval($$.hexF.edges);
            $maps:= $edges[$.label = "map"];

            /* Tops are nodes which have mappings from others to them, but have no mappings to others */
            $tops:= $distinct($maps[$not($.target in $maps.source)].target);
            $tops:= $nodes[$.id in $tops];

            $tops:= $map($tops, function($v) {
              $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
            });

            $tops_count:= $count($tops) = 0 ? "0" : $count($tops);

            /* Leafs here are nodes which have nor to or from mappings */
            $leafs:= $nodes.id[$not($ in $maps.target) and $not($ in $maps.source)];
            $leafs_count:= $count($leafs) = 0 ? "0" : $count($leafs);
                
            $levels:= $expansion != "" ?
              (    
                $exp_path:= $split($expansion, ".");$log($exp_path);
                $exp_path_deep:= $exp_path != "" ? $count($exp_path): 0;$log($exp_path_deep);

                $exp_path_deep > 0 ? 
                    $map($exp_path, function($v, $i) {(
                      $log($exp_path_deep, "check");
                      $url_tail_calc:= function($arr, $ii, $url) {(
                        $url:= $url & $arr[$ii] & ".";
                        $ii < $i ? $url_tail_calc($arr, $ii+1, $url) : $url
                      )}; 
                      $url_tail:= $url_tail_calc($exp_path, 0, "");
                      $maps:= $edges[$.target = $v and $.label="map"];
                      $members:= $maps.source;
                      $leafs:= $members[$not($ in $edges[$.label = "map"].target)];
                      $members:= $members[$not($ in $leafs)];

                      $leafs:= $nodes[$.id in $leafs];
                      $members:= $nodes[$.id in $members];

                      $members:= $map($members, function($v) {
                        $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
                      });

                      $leafs_count:= $count($leafs)=0 ? "0" : $count($leafs);
                      $members_count:= $count($members)=0 ? "0" : $count($members);

                      {"id": "l" & $string($i+1),
                       "title": "level " & $string($i+1),
                       "members": $members, 
                       "members_count": $members_count, 
                       "leafs": {"id": "leafs" & $i, "title": "Leafs"},
                       "leafs_count": $leafs_count, 
                       "maps": $maps[$.source in $members.id], 
                       "url": $$.hexEnv.url & "entities/lake/whole_landscape?expansion=" & $url_tail}
                    )});
              );



            {"tops": $tops,
             "tops_count": $tops_count,
             "leafs": {"id": "leafs", "title": "Leafs"},
             "leafs_count": $leafs_count,
             "levels": $levels,
             "url": $$.hexEnv.url & "entities/lake/whole_landscape?expansion="
            }
            */
          )

      seq:
        type: PlantUml
        template: seq.puml
        source: >
          (
            {"t": t}          
          )

  hexQuery:
    schema:
      type: object
      patternProperties:
        ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
          type: object
          properties:
            title:
              title: Крткое название запроса
              type: string
            description:
              title: Описание предполагаемого результата выполнения запроса
              type: string
            hexQ:
              title: Тело запроса
              type: object
          required:
            - hexQ
      additionalProperties: false

    
  hexQ:

    menu: >
      (

        $menu:= $map($keys($$.hexQ), function($v) {
                                    { "link": "/entities/hexQ/query?id=" & $v,
                                      "location": "hexQ/" & $lookup(hexQ, $v).title
                                    }
                                  })

      )

    presentations:
      query:
        type: markdown
        template: query.md

        source: >
          (
            $qId:= $params.id;
            $body:= $lookup(hexQ, $qId);
            $qRes:= $eval($$.hexF.query, {"qId": $qId});
            {"qId": $qId, "body": $body, "response": $spread($qRes)}
          )

      query_graph:
        type: PlantUml
        template: query_graph.puml

        source: >
          (
            $qId:= $params.id;
            $pattern:= $eval($$.hexF.query, {"qId": $qId}).chains;

            $elements:=  $map($pattern, function($path) {($log($path);
                            $map($path.path, function($v, $i) {(
                                $target:= $path.path[$i+1] ? $path.path[$i+1];
                                $source:= $v;

                                $target:= $target and ($target = "AND" or $target = "OR" or $target = "AND NOT" or $target = "OR NOT") ?
                                    $replace($source & " " & $target, " ", ""): $target;
                                
                                $source:= $source = "AND" or $source = "OR" or $source = "AND NOT" or $source = "OR NOT" ?
                                    $replace($path.path[$i-1] & " " & $source, " ", "") : $source;
              
                                $edge:= $target ?
                                    {"source": $source, "target": $target};

                                $node:= $source;$log($edge, $source & " " & $target);
                                {"node": $node, "edge": $edge}
                            )})
                        )});$log($pattern);
            $nodes:= $distinct($elements.node);
            $edges:= $distinct($elements.edge);
            {"nodes": $nodes, "edges": $edges}
          )

      query_nests:
        type: PlantUml
        template: query_nests.puml

        source: >
          (
            $qId:= $params.id;
            $pattern:= $eval($$.hexF.query, {"qId": $qId}).chains;

            $nests:=  $map($pattern, function($path) {($log($path);
                            $getNests:= function ($path_arr, $i, $path_dot, $nests) {(
                                $log($path_arr[$i], "1: " & $path_arr[$i]); $log($path_arr[$i+1], "2: " & $path_arr[$i+1]); $log($i, $i & " out of  " & ($count($path_arr)-1));
                                $node:= $path_arr[$i+1] ? $path_dot & $path_arr[$i+1] : $path_dot & $path_arr[$i];

                                $path_dot:= $path_arr[$i+1] ? $node & "." : $path_dot;
                                $nests:= $append($nests, $node);

                                $i<=$count($path_arr)-2 ? $getNests($path_arr, $i+2, $path_dot, $nests) : {"nests": $nests, "path_dot": $path_dot};
                            )};
                            $nests:= $getNests($path.path, 0, "", []);
                        )});

            {"nests": $distinct($nests.nests)}

          )


# hexF:



#   l1: >
#     (
#       $l0:= $.ctx;

#       $edges:= $eval($$.hexF.edges);
#       $l1NodesId:= $edges[$.target = $l0 and $.label = "map"].source;
#       $l1Regs:= $edges[$.source in $l1NodesId and $.target in $l1NodesId];
#       $l1Nodes:= $eval($$.hexF.nodes)[$.id in $l1NodesId];

#       $l1Nodes:= $map($l1Nodes, function($v) {
#         $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
#       });


#       $res:= {"l1Nodes": $l1Nodes, "l1Regs": $l1Regs}
    
#     )

#   getModes: >
#     (
#       $modes_id:= $.id;
#       $selection:= $.active;
#       $selection:= $selection = "" ? "0"

#       $modes_id:= "bySize";
#       $selection:= "1.0";

#       $modes:= $lookup($$.hexModes, $modes_id);

#       $build_tree:= function ($root, $path, $lev, $arr) {(
#       $path:= $path[$lev] ? $append($path, "0") : $path;
#       $log($root, "iter");
#         $arr:= $append($arr,$root?
#           (
#             $prefix:= $lev=0 ? $modes_id : $modes_id & "." & $join($path[0-$lev], ".");

#             $branch:= $map($root, function($v, $i) {(
#               {"id": $i, "title": $v.title, "active": $exists($path[$lev]) and $number($path[$lev])=$i ? true : $i=0 ? true , "includes": $v.includes ? $v.includes}
#             )});

#             {"prefix": $prefix, "branch": $branch}
#           )
#             :
#           $arr);
#         $log($arr, "after iter"); $log($arr[$path[$lev]].branch, "row");
#         $has_includes:= $map($arr[$path[$lev]].branch, function($v, $i) {(
#             $log($path[$lev], "folder");
#           $i = $number($path[$lev]) and $v.includes ? $v.includes
#         )});$log($has_includes, "drill down");

#         $count($has_includes) > 0 ? $build_tree($has_includes, $path, $lev+1, $arr~>|$[$path[$lev]].branch|{}, ["includes"]|) : $arr;
        
#       )};

#       $tree:= $build_tree ($modes.includes, $split($selection, "."), 0, [])

#       /*
#       $modes:= $type($modes) = "object" ?

#         (
#           $modes.* = "(@)enum" ? 
#             (
#               $modesL1:= $eval($$.hexF.l1, {"ctx": $keys($modes)});
#               $map($modesL1.l1Nodes, function($v, $i) {(
#                   {"title": $v.body.title, $v.id: "only", "active": $active_mode ? ($v.id = $active_mode ? true : false) : $i = 0 ? true : false}
#               )});
#             ) : null
#         ) : $type($modes) = "array" ?

#         (
        
        
#         );
#       */
#     )

hexNav:
  - title: Траверсинг
    link: "/entities/observable/traversing"
  - title: Sequence
    link: "entities/observable/seq"
  - title: Dashboards
    link: 
    params:
    includes:
      - title: Traverse tags
        link: "/entities/observable/whole_landscape"
      - title: Menu



