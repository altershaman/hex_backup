# Hexagon core entities


imports:
  # - hex_lang/ttl_declaration_el_interm.yaml
  # - hex_lang/ttl_declaration_advanced_1.yaml
  # - hex_lang/ttl_declaration_advanced_2.yaml
  # - hex_lang/hex_declaration.yaml


entities:



  hexQuery:
    schema:
      type: object
      patternProperties:
        ^[0-9a-zA-Z][a-zA-Z0-9_-]*(\.[a-zA-Z][a-zA-Z0-9_-]*)*$:
          type: object
          properties:
            title:
              title: Крткое название запроса
              type: string
            description:
              title: Описание предполагаемого результата выполнения запроса
              type: string
            hexQ:
              title: Тело запроса
              type: object
          required:
            - hexQ
      additionalProperties: false

    
  hexQ:

    menu: >
      (

        $menu:= $map($keys($$.hexQ), function($v) {
                                    { "link": "/entities/hexQ/query?id=" & $v,
                                      "location": "hexQ/" & $lookup(hexQ, $v).title
                                    }
                                  })

      )

    presentations:
      query:
        type: markdown
        template: query.md

        source: >
          (
            $qId:= $params.id;
            $body:= $lookup(hexQ, $qId);
            $qRes:= $eval($$.hexF.query, {"qId": $qId});
            {"qId": $qId, "body": $body, "response": $spread($qRes)}
          )

      query_graph:
        type: PlantUml
        template: query_graph.puml

        source: >
          (
            $qId:= $params.id;
            $pattern:= $eval($$.hexF.query, {"qId": $qId}).chains;

            $elements:=  $map($pattern, function($path) {($log($path);
                            $map($path.path, function($v, $i) {(
                                $target:= $path.path[$i+1] ? $path.path[$i+1];
                                $source:= $v;

                                $target:= $target and ($target = "AND" or $target = "OR" or $target = "AND NOT" or $target = "OR NOT") ?
                                    $replace($source & " " & $target, " ", ""): $target;
                                
                                $source:= $source = "AND" or $source = "OR" or $source = "AND NOT" or $source = "OR NOT" ?
                                    $replace($path.path[$i-1] & " " & $source, " ", "") : $source;
              
                                $edge:= $target ?
                                    {"source": $source, "target": $target};

                                $node:= $source;$log($edge, $source & " " & $target);
                                {"node": $node, "edge": $edge}
                            )})
                        )});$log($pattern);
            $nodes:= $distinct($elements.node);
            $edges:= $distinct($elements.edge);
            {"nodes": $nodes, "edges": $edges}
          )

      query_nests:
        type: PlantUml
        template: query_nests.puml

        source: >
          (
            $qId:= $params.id;
            $pattern:= $eval($$.hexF.query, {"qId": $qId}).chains;

            $nests:=  $map($pattern, function($path) {($log($path);
                            $getNests:= function ($path_arr, $i, $path_dot, $nests) {(
                                $log($path_arr[$i], "1: " & $path_arr[$i]); $log($path_arr[$i+1], "2: " & $path_arr[$i+1]); $log($i, $i & " out of  " & ($count($path_arr)-1));
                                $node:= $path_arr[$i+1] ? $path_dot & $path_arr[$i+1] : $path_dot & $path_arr[$i];

                                $path_dot:= $path_arr[$i+1] ? $node & "." : $path_dot;
                                $nests:= $append($nests, $node);

                                $i<=$count($path_arr)-2 ? $getNests($path_arr, $i+2, $path_dot, $nests) : {"nests": $nests, "path_dot": $path_dot};
                            )};
                            $nests:= $getNests($path.path, 0, "", []);
                        )});

            {"nests": $distinct($nests.nests)}

          )


# hexF:



#   l1: >
#     (
#       $l0:= $.ctx;

#       $edges:= $eval($$.hexF.edges);
#       $l1NodesId:= $edges[$.target = $l0 and $.label = "map"].source;
#       $l1Regs:= $edges[$.source in $l1NodesId and $.target in $l1NodesId];
#       $l1Nodes:= $eval($$.hexF.nodes)[$.id in $l1NodesId];

#       $l1Nodes:= $map($l1Nodes, function($v) {
#         $v~>|$.body|{"title": $eval($$.hexF.title_break, {"str": $.title})}|
#       });


#       $res:= {"l1Nodes": $l1Nodes, "l1Regs": $l1Regs}
    
#     )

#   getModes: >
#     (
#       $modes_id:= $.id;
#       $selection:= $.active;
#       $selection:= $selection = "" ? "0"

#       $modes_id:= "bySize";
#       $selection:= "1.0";

#       $modes:= $lookup($$.hexModes, $modes_id);

#       $build_tree:= function ($root, $path, $lev, $arr) {(
#       $path:= $path[$lev] ? $append($path, "0") : $path;
#       $log($root, "iter");
#         $arr:= $append($arr,$root?
#           (
#             $prefix:= $lev=0 ? $modes_id : $modes_id & "." & $join($path[0-$lev], ".");

#             $branch:= $map($root, function($v, $i) {(
#               {"id": $i, "title": $v.title, "active": $exists($path[$lev]) and $number($path[$lev])=$i ? true : $i=0 ? true , "includes": $v.includes ? $v.includes}
#             )});

#             {"prefix": $prefix, "branch": $branch}
#           )
#             :
#           $arr);
#         $log($arr, "after iter"); $log($arr[$path[$lev]].branch, "row");
#         $has_includes:= $map($arr[$path[$lev]].branch, function($v, $i) {(
#             $log($path[$lev], "folder");
#           $i = $number($path[$lev]) and $v.includes ? $v.includes
#         )});$log($has_includes, "drill down");

#         $count($has_includes) > 0 ? $build_tree($has_includes, $path, $lev+1, $arr~>|$[$path[$lev]].branch|{}, ["includes"]|) : $arr;
        
#       )};

#       $tree:= $build_tree ($modes.includes, $split($selection, "."), 0, [])

#       /*
#       $modes:= $type($modes) = "object" ?

#         (
#           $modes.* = "(@)enum" ? 
#             (
#               $modesL1:= $eval($$.hexF.l1, {"ctx": $keys($modes)});
#               $map($modesL1.l1Nodes, function($v, $i) {(
#                   {"title": $v.body.title, $v.id: "only", "active": $active_mode ? ($v.id = $active_mode ? true : false) : $i = 0 ? true : false}
#               )});
#             ) : null
#         ) : $type($modes) = "array" ?

#         (
        
        
#         );
#       */
#     )



